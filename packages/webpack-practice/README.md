# Webpack

## Why webpack

브라우저에서 자바스크립트가 동작하는 두 가지 방법이 있다.
먼저 각 기능이 있는 스크립트를 추가한다.
이 방식은 너무 많은 스크립트로 인해 네트워크의 병목을 유발하여 확장을 어렵게 한다.
두 번째는 하나의 거대한 `.js`파일을 만든다.
이는 유효범위, 크기, 가독성, 유지보수 문제를 발생시킨다.

웹팩 이전에는 파일의 순서를 신경써야 했다.

- 해당 스크립트가 외부 라이브러리에 의존한다는 것이 명확하지 않다.
- 의존성을 잃어버렸거나 잘못된 순서로 포함되었으면 애플리케이션이 제대로 작동하지 않는다.
- 의존성이 포함되었지만 사용되지 않는 경우에도 브라우저는 필요없는 코드를 강제로 다운로드한다.

### IIFEs - Immediately invoked function expressions

대규모 프로젝트에서 유효범위 문제를 해결한다.
스크립트 파일을 IIFE로 감싸면 유효범위에 대한 걱정없이 파일을 연결, 결합할 수 있다.
그러나 하나의 파일을 변경해도 전체를 다시 빌드해야 한다.

### Birth of JavaScript Modules happened thanks to Node.js

웹팩은 브라우저 외부 환경의 서버나 컴퓨터에서 사용할 수 있는 자바스크립트 런타임인 Node.js에서 동작한다.

## 번들 개념의 등장

“소스”코드: 우리가 작성하고 편집하는 코드

“배포”코드: 빌드 과정을 통해 최소화하고 최적화되어 궁극적으로 브라우저에서 로드될 출력물

기본적으로 `src/index.js` 를 엔트리 포인트로 사용하고 결과물로 `dist/main.js` 을 생성

## require / exports 구문

그러나 `CommonJS`에 대한 브라우저의 지원은 없다.
동기적인 모듈 해석과 로딩이 느리다.
`CommonJS`가 Node.js에서는 뛰어난 솔루션이지만 브라우저는 모듈을 지원하지 않았다.

## import / export 구문 - `ES2015` 에서 표준화

현재는 대부분의 브라우저에서 지원되지만, 몇몇 브라우저에서는 새 구문을 인식하지 못한다.

보이지 않는 곳에서 webpack이 실제로 코드를 “트랜스파일”하여 이전 브라우저에서도 실행할 수 있도록 한다.

## Configuration

### Entry

웹팩이 내부 디펜던시 그래프를 생성하기 위해 사용해야 하는 모듈

웹팩은 엔트리 포인트가 의존하는 다른 모듈과 라이브러리를 찾아낸다.

기본값은 `./src/index.js`

### Output

생성된 번들을 내보낼 위치와 이 파일의 이름을 지정하는 방법을 웹팩에 알려주는 역할

기본값은 `./dist/main.js`

### Loaders

웹팩은 기본적으로 자바스크립트와 `JSON` 파일만 이해한다.
로더를 사용하면 다른 유형의 파일을 처리할 수 있다.

1. 변환이 필요한 파일(들)을 식별하는 `test` 속성
2. 변환을 수행하는데 사용되는 로더를 가리키는 `use` 속성

### Plugins

로더는 특정 유형의 모듈을 변환하는데 사용되지만 플러그인을 활용하여 번들을 최적화하거나 애셋을 관리하고 또 환경 변수 주입 등과 같은 광범위한 작업을 수행할 수 있다.

### Mode

### Browser Compatibility

### Environment

## Asset Modules

- asset/resource: 별도의 파일을 내보내고 URL을 추출한다. 이전에는 `file-loader` 사용하여 처리.
- asset/inline: 애셋의 data URI를 내보낸다. 이전에는 `url-loader`를 사용하여 처리.
- asset: data URI와 별도의 파일 내보내기 중에서 자동으로 선택한다. 이전에는 애셋 크기의 제한이 있는 `url-loader`를 사용.
- asset/source: 애셋의 소스 코드를 내보낸다. 이전에는 `raw-loader`를 사용하여 처리.
