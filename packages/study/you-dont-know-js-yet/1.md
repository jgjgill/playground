# 자바스크립트

`alert()` 와 `console.log()` 는 JS에 정의된 문법이 아니지만, JS의 함수와 객체 메서드 규칙을 따르고 JS처럼 보인다.

`alert` 호출은 JS이지만 `alert` 자체는 명세서에 없는 손님이다.

개발자 도구가 JS의 프로그램 처리 방식을 항상 엄격하게 준수하지 않는다.

개발자 도구는 ‘JS에 우호적인’ 별도의 환경이다.

JS는 다중 패러다임 언어라 절차적, 객체 지향, 함수형 스타일 코드 모두 작성 가능하다.

## 하위 호환성과 상위 호환성

하위 호환성: 단 한 번이라도 유효한 JS 문법이라고 인정되면 명세서가 변경되더라도 절대 그 유효성이 깨지지 않는다.

상위 호환성: 새로운 명세서에 추가된 문법으로 코드를 작성했을 때 이전 명세서를 준수하는 구형 JS 엔진에서 문제가 발생하지 않아야 한다.

JS는 상위 호환성을 보장하지 않는다.

## 간극을 줄이기 위한 노력

- 트랜스파일: 한 형태에서 다른 형태로 소스 코드를 변환해준다.
- 변환 후 산출물은 소스 코드이다.
- 트랜스파일러는 새로운 JS 문법을 오래된 문법으로 바꿔준다. ex) 바벨

## 간극을 메우기 위한 방법 찾기

`finally()` 에 대한 폴리필 예시

```js
if (!Promise.prototype.finally) {
  Promise.prototype.finally = function f(fn) {
    return this.then(
      function t(v) {
        return Promise.resolve(fn()).then(function t() {
          return v
        })
      },
      function c(e) {
        return Promise.resolve(fn()).then(function t() {
          throw e
        })
      },
    )
  }
}
```

- JS는 진화를 멈추지 않는 언어이므로 간극은 절대 사라지지 않는다.
- JS 기반으로 프로젝트를 만들 때 트랜스파일이나 폴리필 사용이 표준으로 자리 잡아야 한다.

### 인터프리터 이해하기

- 파싱
- 컴파일

트랜스파일 → 번들링 → JS 엔진에 전달 → 코드 파싱 (추상 구문 트리) → 추상 구문 트리를 이진 바이트 코드로 변경 (JIT 컴파일러 작동) → JS 가상 머신이 프로그램 실행

JS는 인터프리터 언어일까, 컴파일 언어일까?

→ 필자는 컴파일 언어라고 생각한다.

웹어셈블리 (Wasm): 웹 브라우저에서 실행될 수 있는 이진 형태의 소스 코드

- JS가 주력이 아닌 개발자도 JS 엔진에서 돌아가는 코드를 쉽게 작성할 수 있게 해주는데 목적
- 어셈블리 언어와 유사, 파싱과 컴파일 없이 처리

# 자바스크립트 조망하기

JS에서는 파일 각각이 별도의 프로그램

파일을 프로그램으로 취급하기 때문에 파일 하나에만 오류가 있어도 다음 파일 처리되지 않을 수 있음

## 변수 선언과 사용

`const` 로 선언한 변수는 재할당이 불가능할 뿐이지 값을 바꿀 수 없는 것은 아니다.

어떻게 보면 `const` 를 사용해 객체를 정의하는 건 좋지 않은 방식이다.

객체를 재할당하는 건 불가능하지만 값은 바꿀 수 있기 때문이다.

재할당 - `const` 로 선언한 변수에는 허용되지 않음

값 변경 - `const` 로 선언한 변수에 가능함

```tsx
function hello(myName) {
  console.log(`${myName} 님, 안녕하세요.`)
}

hello('카일')
```

`hello` 와 `myName` 은 `var` 로 선언한 변수처럼 작동

```tsx
try {
  someError()
} catch (err) {
  console.log(err)
}
```

`err` 스코프는 `let` 으로 선언한 변수처럼 블록 스코프

## 함수

프로시저: 한 번 이상 호출할 수 있고 입력값이 있을 수 있으며 하나 이상의 출력값을 반환하는 구문의 모음

- 함수는 할당 가능하고 어디든 전달 가능한 값
- 함수는 객체의 한 종류

## 같음에 대한 고찰

- 일치 비교
- 동등 비교

## 강제 변환

강제 변환: 한 타입의 값이 다른 타입의 값으로 변하는 걸 의미

`==` 연산자는 강제 변환을 먼저 실행해 피연산자의 타입을 맞춘 이후 `===` 연산자처럼 작동

`==` 연산자는 숫자형 피연산자를 선호

피연산자 모두가 문자열인 경우 사전처럼 알파벳순으로 문자열 비교

```tsx
var x = '10'
var y = '9'

x < y // true
```

## 코드 구조화 패턴

- 클래스
- 모듈

# 자바스크립트 뿌리 파헤치기

## 이터레이션

반복 작업으로 데이터를 처리할 때 표준화된 방법을 제공

### 이터러블

이터레이터 소비 프로토콜

- 순회 가능한 값인 이터러블(iterable)을 소비하는 기술적인 방법
- 이터러블을 사용해 이터레이터 인스턴스 생성, 생성한 이터레이터 인스턴스를 소비해 연산 마무리

어떤 게 이터러블인가?

ES6에서는 문자열, 배열, 맵, 셋 같이 기본이 되는 자료구조나 컬렉션을 이터러블로 정의

맵은 배열이나 문자열같은 이터레이터와는 다르게 기본 이터레이터를 지원

### 클로저

함수가 정의된 스코프가 아닌 다른 스코프에서 함수가 실행되더라도, 스코프 밖에 있는 변수를 기억하고 이 외부 변수에 계속 접근할 수 있는 경우를 의미

- 클로저는 함수의 타고난 특징
- 클로저를 직접 보고 싶다면 함수를 해당 함수가 정의된 스코프가 아닌 다른 스코프에서 실행

외부 스코프에 있는 변수를 기억하는 현상 (close over)

클로저는 외부 스코프에 기억된 변수를 스냅숏한 값(복사해서 별도로 만든 값)을 사용하지 않는다.

대신 변수 자체와 직접적인 관계를 맺어 변수가 업데이트되는 것을 관찰하고 최신 값을 가져와서 사용

### this 키워드

- 함수는 정의되는 시점에 클로저를 통해 함수를 에워싸는 스코프에 부착
- 스코프는 변수가 어떤 것을 참조하는지 결정하는 규칙 모음
- 함수는 스코프 말고도 자신이 어디까지 접근 가능한지를 결정 (실행 컨텍스트)

- 스코프는 정적이며 함수를 정의하는 순간 해당 스코프에서 사용할 수 있는 한정된 변수 집합을 포함
- 함수의 실행 컨텍스트는 동적. 실행 컨텍스트는 함수를 정의한 위치나 함수를 호출하는 위치와 상관없이 함수의 호출 방식에 따라 결정
- this 또한 함수를 호출할 때마다 결정되는 동적인 특성

### 프로토타입

- 프로토타입은 객체, 구체적으로 프로퍼티에 접근할 때 일어나는 동작과 관련된 특징
- 프로토타입은 두 객체를 연결하는 연결 장치
- 프로토타입은 객체가 생성될 때 만들어지고 이 장치를 통해 새롭게 생성된 객체는 기존에 존재하는 다른 객체에 연결

```tsx
var homework = {
  topic: 'JS',
}

homework.toString() // [object Object]
```

`homework` 객체에는 `topic` 이라는 프로퍼티만 존재

하지만 `homework` 의 기본 프로퍼티 연결 장치가 `homework` 와 `object.prototype` 객체를 연결

`object.prototype` 에 있는 내장 메서드 `toString()` 이나 `valueOf()` 등의 메서드도 사용 가능

### 객체 연결 장치

객체 프로토타입 연결 장치를 직접 정의하고 싶을 때는 `Object.create()` 를 사용해 객체 생성

```tsx
var homework = {
  topic: 'JS',
}

var otherHomework = Object.create(homework)

otherHomework.topic // "JS"
```

### this 다시 보기

함수 호출 시 `this` 가 동적으로 컨텍스트를 가져오는 중요한 이유는 프로토타입 체인을 통해 위임한 객체에 있는 메서드를 호출할 때 `this` 가 코드 작성자의 의도대로 되게끔 하는 데 있음

다른 언어들과 달리 JS에서는 `this` 가 동적으로 결정

# 더 큰 그림

## 첫 번째 기둥: 스코프와 클로저

스코프 안에 다른 스코프가 올 수 있다.

이렇게 스코프가 중첩될 때 표현식이나 문은 해당 레벨의 스코프 혹은 더 높거나 바깥 레벨에 있는 변수에만 접근 가능하다.

낮거나 안쪽 레벨 스코프에 있는 숨겨진 변수에는 접근할 수 없다.

이를 렉시컬 스코프(어휘 스코프)라고 부른다.

JS는 렉시컬 스코프 모델을 채택하고 있지만 두 가지 다른 특징을 갖는다.

첫 번째는 호이스팅이다. 두 번째는 `var` 를 사용해 선언한 변수는 함수 기준으로 스코프가 만들어진다는 것이다.

클로저는 바깥 스코프에 있는 변수를 참조하는 함수가 있고, 이 함수가 변수를 통해 별개의 스코프에서 실행될 때, 함수는 함수가 정의된 스코프르 기준으로 변수를 참조한다.

## 두 번째 기둥: 프로토타입

프로토타입을 사용하면 `this` 컨텍스트가 공유되면서 두 객체를 아주 간편하게 연결할 수 있고 함수나 메서드가 실행되는 동안 두 객체를 동적으로 협력할 수 있다.

클래스는 프로토타입이 가진 강력한 힘을 기반으로 하는 하나의 패턴에 불과하다.

작동 위임 (behavior delegation)

객체는 객체로서 그대로 두고, 클래스 없이 프로토타입 체인을 통해 객체가 협력하도록 하는 접근법

## 세 번째 기둥: 타입과 타입 강제 변환

JS에서 타입이 어떻게 작동하는가

# 더 멀리 나가기

## 다양한 형태의 함수

JS는 익명 함수이더라도 자체적으로 이름을 추론할 수 있다.

할당 연산자를 사용해 함수 표현식을 할당한 것 같은 제한적인 상황에서 발생한다.

```tsx
var awesomeFunction = function (coolThings) {
  return amzingStuff
}

awesomeFunction.name // 'awesomeFunction'
```

추론을 통해 이름을 부여받아도 익명 함수는 여전히 익명 함수이다.

추론된 이름은 문자열 형태의 메타데이터일 뿐, 해당 함수를 참조하는 유효한 식별자가 아니다.

익명 함수는 본문 안에서 자기 자신을 참조할 수 있는 식별자를 갖지 못한다.

이런 특징은 재귀를 사용하거나 등록된 이벤트르 해제할 때 문제가 된다.

프로그램 내에 있는 함수는 목적이 있어야 한다.

목적이 있는 함수에는 목적을 설명하는 자연스러운 이름을 부여해야 한다.

## 프로토타입 클래스

다음 두 코드는 동일하게 작동한다.

```tsx
var Classroom = {
  welcome() {
    console.log('학생 여러분, 환영합니다!')
  },
}

var mathClass = Object.create(Classroom)

mathClass.welcome()
// 학생 여러분 환영합니다!
```

```tsx
function Classroom() {
  // ...
}

Classroom.prototype.welcome = function hello() {
  console.log('학생 여러분, 환영합니다!')
}

var mathClass = new Classroom()

mathClass.welcome()
// 학생 여러분, 환영합니다!
```

ES6 클래스 메커니즘으로도 쓸 수 있다.

```tsx
class Classroom {
  constructor() {
    // ...
  }

  welcome() {
    console.log('학생 여러분, 환영합니다!')
  }
}

var mathClass = new Classroom()

mathClass.welcome()
// 학생 여러분, 환영합니다!
```

클래스 메커니즘과 프로토타입 클래스 모두 밑바닥에서는 동일한 프로토타입 연결 장치로 설정되어 있다.

클래스 지향 디자인 패턴에서는 클래스가 훨씬 더 잘 맞는다.
