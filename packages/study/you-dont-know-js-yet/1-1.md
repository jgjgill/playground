# 자바스크립트

`alert()` 와 `console.log()` 는 JS에 정의된 문법이 아니지만, JS의 함수와 객체 메서드 규칙을 따르고 JS처럼 보인다.

`alert` 호출은 JS이지만 `alert` 자체는 명세서에 없는 손님이다.

개발자 도구가 JS의 프로그램 처리 방식을 항상 엄격하게 준수하지 않는다.

개발자 도구는 ‘JS에 우호적인’ 별도의 환경이다.

JS는 다중 패러다임 언어라 절차적, 객체 지향, 함수형 스타일 코드 모두 작성 가능하다.

## 하위 호환성과 상위 호환성

하위 호환성: 단 한 번이라도 유효한 JS 문법이라고 인정되면 명세서가 변경되더라도 절대 그 유효성이 깨지지 않는다.

상위 호환성: 새로운 명세서에 추가된 문법으로 코드를 작성했을 때 이전 명세서를 준수하는 구형 JS 엔진에서 문제가 발생하지 않아야 한다.

JS는 상위 호환성을 보장하지 않는다.

## 간극을 줄이기 위한 노력

- 트랜스파일: 한 형태에서 다른 형태로 소스 코드를 변환해준다.
- 변환 후 산출물은 소스 코드이다.
- 트랜스파일러는 새로운 JS 문법을 오래된 문법으로 바꿔준다. ex) 바벨

## 간극을 메우기 위한 방법 찾기

`finally()` 에 대한 폴리필 예시

```js
if (!Promise.prototype.finally) {
  Promise.prototype.finally = function f(fn) {
    return this.then(
      function t(v) {
        return Promise.resolve(fn()).then(function t() {
          return v
        })
      },
      function c(e) {
        return Promise.resolve(fn()).then(function t() {
          throw e
        })
      },
    )
  }
}
```

- JS는 진화를 멈추지 않는 언어이므로 간극은 절대 사라지지 않는다.
- JS 기반으로 프로젝트를 만들 때 트랜스파일이나 폴리필 사용이 표준으로 자리 잡아야 한다.

### 인터프리터 이해하기

- 파싱
- 컴파일

트랜스파일 → 번들링 → JS 엔진에 전달 → 코드 파싱 (추상 구문 트리) → 추상 구문 트리를 이진 바이트 코드로 변경 (JIT 컴파일러 작동) → JS 가상 머신이 프로그램 실행

JS는 인터프리터 언어일까, 컴파일 언어일까?

→ 필자는 컴파일 언어라고 생각한다.

웹어셈블리 (Wasm): 웹 브라우저에서 실행될 수 있는 이진 형태의 소스 코드

- JS가 주력이 아닌 개발자도 JS 엔진에서 돌아가는 코드를 쉽게 작성할 수 있게 해주는데 목적
- 어셈블리 언어와 유사, 파싱과 컴파일 없이 처리
